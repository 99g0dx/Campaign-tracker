I‚Äôll break it into (A) passwords + forgot password and (B) deeper engagement windows.

A. Change password + Forgot password flow
1. DB changes (if not already there)

In your users table, make sure you have:

// server/db/schema.ts
export const users = pgTable("users", {
  id: text("id").primaryKey(),
  email: text("email").notNull().unique(),
  passwordHash: text("password_hash"),        // for login
  // ...
  resetToken: text("reset_token"),            // for forgot password
  resetTokenExpiresAt: timestamp("reset_token_expires_at"),
});


Run a migration.

Install bcrypt if you haven‚Äôt:

npm install bcrypt

2. Backend: change password (logged-in user)
// server/routes/auth.ts
import bcrypt from "bcrypt";
import crypto from "crypto";
import { users } from "../db/schema";
import { eq } from "drizzle-orm";
import { requireUser } from "../middleware/requireUser";

router.post("/change-password", requireUser, async (req, res) => {
  const { currentPassword, newPassword } = req.body;

  const [user] = await db.select().from(users).where(eq(users.id, req.userId));

  if (!user?.passwordHash) {
    return res
      .status(400)
      .json({ error: "Password login is not enabled for this account" });
  }

  const ok = await bcrypt.compare(currentPassword, user.passwordHash);
  if (!ok) return res.status(401).json({ error: "Current password is incorrect" });

  const newHash = await bcrypt.hash(newPassword, 10);

  await db
    .update(users)
    .set({ passwordHash: newHash })
    .where(eq(users.id, req.userId));

  res.json({ ok: true });
});


Hook this to the Profile page:

// inside ProfilePage.tsx
async function changePassword(e: React.FormEvent) {
  e.preventDefault();
  setError(null);
  try {
    const res = await fetch("/api/auth/change-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ currentPassword, newPassword }),
    });
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || "Could not change password");
    setCurrentPassword("");
    setNewPassword("");
  } catch (err: any) {
    setError(err.message);
  }
}


And the UI block (you already have most of this from earlier; just make sure it actually calls the endpoint):

<section className="rounded-2xl border border-slate-800 bg-slate-900/60 p-6 space-y-4">
  <h2 className="text-sm font-semibold">Password</h2>
  <form onSubmit={changePassword} className="space-y-3 max-w-md">
    <div>
      <label className="text-xs text-slate-400">Current password</label>
      <input
        type="password"
        className="w-full rounded-xl bg-slate-800 px-3 py-2 text-sm"
        value={currentPassword}
        onChange={(e) => setCurrentPassword(e.target.value)}
        required
      />
    </div>
    <div>
      <label className="text-xs text-slate-400">New password</label>
      <input
        type="password"
        className="w-full rounded-xl bg-slate-800 px-3 py-2 text-sm"
        value={newPassword}
        onChange={(e) => setNewPassword(e.target.value)}
        required
      />
    </div>
    <button
      type="submit"
      className="rounded-xl bg-slate-700 px-4 py-2 text-xs font-medium"
    >
      Change password
    </button>
  </form>
</section>

3. Backend: forgot password + reset
// server/routes/auth.ts (same file)
router.post("/forgot-password", async (req, res) => {
  const { email } = req.body;

  const [user] = await db.select().from(users).where(eq(users.email, email));
  if (!user) {
    // do not leak that the email doesn‚Äôt exist
    return res.json({ ok: true });
  }

  const token = crypto.randomBytes(32).toString("hex");
  const expires = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

  await db
    .update(users)
    .set({ resetToken: token, resetTokenExpiresAt: expires })
    .where(eq(users.id, user.id));

  const resetLink = `${process.env.APP_URL}/reset-password?token=${token}`;

  // TODO: replace with real email service
  console.log(`Password reset for ${email}: ${resetLink}`);

  res.json({ ok: true });
});

router.post("/reset-password", async (req, res) => {
  const { token, newPassword } = req.body;

  const [user] = await db
    .select()
    .from(users)
    .where(eq(users.resetToken, token));

  if (
    !user ||
    !user.resetTokenExpiresAt ||
    user.resetTokenExpiresAt < new Date()
  ) {
    return res.status(400).json({ error: "Invalid or expired reset link" });
  }

  const hash = await bcrypt.hash(newPassword, 10);

  await db
    .update(users)
    .set({
      passwordHash: hash,
      resetToken: null,
      resetTokenExpiresAt: null,
    })
    .where(eq(users.id, user.id));

  res.json({ ok: true });
});


For now, the reset link will appear in the server console; when you‚Äôre ready you can plug in Resend/SendGrid instead of console.log.

4. Frontend: forgot + reset pages

Login page: add the link:

<p className="mt-3 text-xs text-slate-400 text-right">
  <a href="/forgot-password" className="hover:underline">
    Forgot password?
  </a>
</p>


ForgotPassword page:

// client/src/pages/ForgotPassword.tsx
export default function ForgotPassword() {
  const [email, setEmail] = useState("");
  const [sent, setSent] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError(null);
    const res = await fetch("/api/auth/forgot-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email }),
    });
    if (!res.ok) {
      const data = await res.json().catch(() => ({}));
      setError(data.error || "Something went wrong");
      return;
    }
    setSent(true);
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950 text-white">
      <div className="w-full max-w-md rounded-2xl border border-slate-800 bg-slate-900/70 p-8 shadow-xl">
        <h1 className="text-xl font-semibold mb-2">Reset your password</h1>
        <p className="text-xs text-slate-300 mb-4">
          Enter your email and we&apos;ll send you a reset link.
        </p>

        {sent ? (
          <p className="text-xs text-slate-300">
            If there&apos;s an account with that email, a reset link has been
            sent.
          </p>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-3">
            <input
              type="email"
              className="w-full rounded-xl bg-slate-800 px-3 py-2 text-sm"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="you@example.com"
              required
            />
            {error && <p className="text-xs text-red-400">{error}</p>}
            <button
              type="submit"
              className="w-full rounded-xl bg-orange-500 py-2 text-sm font-medium"
            >
              Send reset link
            </button>
          </form>
        )}
      </div>
    </div>
  );
}


ResetPassword page:

// client/src/pages/ResetPassword.tsx
import { useSearchParams, useNavigate } from "react-router-dom";

export default function ResetPassword() {
  const [params] = useSearchParams();
  const navigate = useNavigate();
  const token = params.get("token") || "";
  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [error, setError] = useState<string | null>(null);

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (password !== confirm) {
      setError("Passwords do not match");
      return;
    }
    setError(null);
    const res = await fetch("/api/auth/reset-password", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ token, newPassword: password }),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      setError(data.error || "Reset failed");
      return;
    }
    navigate("/login");
  }

  if (!token) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-slate-950 text-white">
        <p className="text-xs text-red-400">Invalid reset link</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-950 text-white">
      <div className="w-full max-w-md rounded-2xl border border-slate-800 bg-slate-900/70 p-8 shadow-xl">
        <h1 className="text-xl font-semibold mb-2">Choose a new password</h1>
        <form onSubmit={handleSubmit} className="space-y-3">
          <input
            type="password"
            className="w-full rounded-xl bg-slate-800 px-3 py-2 text-sm"
            placeholder="New password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
          <input
            type="password"
            className="w-full rounded-xl bg-slate-800 px-3 py-2 text-sm"
            placeholder="Confirm password"
            value={confirm}
            onChange={(e) => setConfirm(e.target.value)}
            required
          />
          {error && <p className="text-xs text-red-400">{error}</p>}
          <button
            type="submit"
            className="w-full rounded-xl bg-orange-500 py-2 text-sm font-medium"
          >
            Reset password
          </button>
        </form>
      </div>
    </div>
  );
}


Add routes:

// App.tsx
<Route path="/forgot-password" element={<ForgotPassword />} />
<Route path="/reset-password" element={<ResetPassword />} />

B. Deep engagement windows (24h, 72h, 7/30/60/90 days)

You already have campaign stats + charts. Let‚Äôs bolt on time-window summaries.

1. Backend aggregation

Assuming you have a posts (or campaign_posts) table with:

campaignId

postedAt (or createdAt)

views, likes, comments, shares

Create a route:

// server/routes/campaignEngagement.ts
import { posts } from "../db/schema";
import { sum, and, eq, gte } from "drizzle-orm";
import { subDays, subHours } from "date-fns";

router.get("/:id/engagement-windows", requireUser, async (req, res) => {
  const { id } = req.params;
  const now = new Date();

  const windows = [
    { key: "24h", from: subHours(now, 24) },
    { key: "72h", from: subHours(now, 72) },
    { key: "7d", from: subDays(now, 7) },
    { key: "30d", from: subDays(now, 30) },
    { key: "60d", from: subDays(now, 60) },
    { key: "90d", from: subDays(now, 90) },
  ];

  const results: Record<
    string,
    { views: number; likes: number; comments: number; shares: number }
  > = {};

  for (const w of windows) {
    const [row] = await db
      .select({
        views: sum(posts.views).as("views"),
        likes: sum(posts.likes).as("likes"),
        comments: sum(posts.comments).as("comments"),
        shares: sum(posts.shares).as("shares"),
      })
      .from(posts)
      .where(
        and(
          eq(posts.campaignId, id),
          gte(posts.postedAt, w.from) // use your actual timestamp column
        )
      );

    results[w.key] = {
      views: row?.views ?? 0,
      likes: row?.likes ?? 0,
      comments: row?.comments ?? 0,
      shares: row?.shares ?? 0,
    };
  }

  res.json({ windows: results });
});


Mount under /api/campaigns.

2. Frontend: ‚ÄúEngagement windows‚Äù section on campaign page

On the campaign detail page, fetch this:

// inside CampaignDetailPage.tsx
const [windowStats, setWindowStats] = useState<any | null>(null);

useEffect(() => {
  async function load() {
    const res = await fetch(`/api/campaigns/${campaignId}/engagement-windows`);
    const data = await res.json();
    setWindowStats(data.windows);
  }
  load();
}, [campaignId]);


Render nice cards under your main KPIs:

{windowStats && (
  <section className="mt-6 rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
    <h2 className="text-sm font-semibold mb-3">
      Engagement breakdown by time window
    </h2>
    <div className="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
      {[
        { key: "24h", label: "Last 24 hours" },
        { key: "72h", label: "Last 72 hours" },
        { key: "7d", label: "Last 7 days" },
        { key: "30d", label: "Last 30 days" },
        { key: "60d", label: "Last 60 days" },
        { key: "90d", label: "Last 90 days" },
      ].map((w) => {
        const s = windowStats[w.key] || {
          views: 0,
          likes: 0,
          comments: 0,
          shares: 0,
        };
        return (
          <div
            key={w.key}
            className="rounded-xl bg-slate-900 border border-slate-700 p-3"
          >
            <p className="text-[11px] text-slate-400 mb-1">{w.label}</p>
            <p className="text-lg font-semibold mb-2">
              {s.views.toLocaleString()} views
            </p>
            <div className="flex flex-wrap gap-2 text-[10px] text-slate-300">
              <span>üëç {s.likes.toLocaleString()} likes</span>
              <span>üí¨ {s.comments.toLocaleString()} comments</span>
              <span>‚ÜóÔ∏è {s.shares.toLocaleString()} shares</span>
            </div>
          </div>
        );
      })}
    </div>
  </section>
)}